<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VOID RUNNER - HYPER SMEAR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@300;500;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; }
        
        /* Effects */
        .neon-text { text-shadow: 0 0 8px rgba(34, 211, 238, 0.6); }
        .speed-lines {
            background: repeating-linear-gradient(90deg, transparent 0, transparent 50px, rgba(0, 255, 255, 0.02) 50px, rgba(0, 255, 255, 0.02) 51px);
            position: absolute; inset: 0; z-index: 1; pointer-events: none; opacity: 0.3;
        }
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            width: 100%; height: 100%; opacity: 0; cursor: ns-resize; position: relative; z-index: 20;
        }

        /* Animations */
        .hero-text { transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1), transform 1.5s, filter 1.5s; }
        .fade-out { opacity: 0; filter: blur(15px); transform: scale(1.1); }
        .fade-in { opacity: 1; filter: blur(0px); transform: scale(1); }

        /* Button Styles */
        .btn-base {
            transition: all 0.5s ease;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        /* Active (Auto) */
        .btn-auto {
            border: 1px solid #22d3ee;
            color: #22d3ee;
            background: rgba(34, 211, 238, 0.1);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .btn-auto:hover {
            background: rgba(34, 211, 238, 0.2);
            box-shadow: 0 0 25px rgba(34, 211, 238, 0.5);
        }
        /* Inactive (Manual) */
        .btn-manual {
            border: 1px solid #ef4444;
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            opacity: 0.8;
        }
        .btn-manual:hover {
            opacity: 1;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
        }
    </style>
</head>
<body class="text-white selection:bg-cyan-500 selection:text-black">

    <div id="canvas-container" class="absolute inset-0 z-0"></div>
    <div class="speed-lines"></div>
    <div class="absolute inset-0 z-10 pointer-events-none" style="background: radial-gradient(circle, transparent 30%, #000 130%);"></div>

    <div class="absolute inset-0 z-20 pointer-events-none flex flex-col justify-between p-8">
        
        <div class="font-bold text-lg md:text-xl tracking-[0.3em] uppercase text-cyan-500/80 neon-text" style="text-shadow: 0 0 5px rgba(34,211,238,0.5);">
            jump.into.abyss
        </div>

        <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center w-full max-w-7xl">
            <div id="text-container">
                <h1 id="main-phrase" class="text-4xl md:text-7xl font-black italic tracking-tighter mb-4 hero-text fade-in text-white drop-shadow-lg">
                    
                </h1>
                <p id="sub-phrase" class="text-xs md:text-base font-mono text-cyan-400 tracking-[0.4em] uppercase hero-text fade-in">
                    
                </p>
            </div>
        </div>

        <div class="absolute right-8 top-1/2 -translate-y-1/2 flex flex-col items-center gap-6 pointer-events-auto w-28">
            
            <div class="text-right w-full pr-1">
                <div class="text-[9px] text-gray-500 font-mono tracking-widest mb-1">VELOCITY [C]</div>
                <div id="velocity-display" class="text-xl font-mono text-cyan-300 font-bold tabular-nums border-r-2 border-cyan-500 pr-2">0.08</div>
            </div>

            <div class="h-64 w-12 bg-gray-900/60 border border-gray-700 relative overflow-hidden">
                <div class="absolute inset-0 flex flex-col justify-between py-3 px-1 opacity-40 pointer-events-none">
                    <div class="w-full h-px bg-red-500"></div>
                    <div class="w-1/2 h-px bg-cyan-500 self-end"></div>
                    <div class="w-3/4 h-px bg-cyan-500 self-center"></div>
                    <div class="w-1/2 h-px bg-cyan-500 self-end"></div>
                    <div class="w-full h-px bg-cyan-500"></div>
                </div>
                <div id="throttle-fill" class="absolute bottom-0 left-0 w-full bg-cyan-500/40 border-t border-cyan-300 transition-none box-shadow-glow" style="height: 4%;"></div>
                <input type="range" orient="vertical" id="speed-slider" min="0" max="100" value="4">
            </div>

            <button id="autopilot-btn" onclick="toggleAutopilot()" class="w-32 -ml-4 py-4 px-2 rounded-sm btn-base btn-auto flex flex-col items-center justify-center gap-1 group">
                <span class="text-[9px] tracking-widest font-bold text-gray-400 group-hover:text-white transition-colors">SYSTEM: PILOT</span>
                <span id="btn-status" class="text-[12px] font-black tracking-widest animate-pulse">ENGAGED</span>
            </button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js'; // IMPORTED
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';

        // --- TEXT SEQUENCER ---
        const phrases = [
            { main: "", sub: "" },
            { main: "", sub: "" },
            { main: "", sub: "" },
            { main: "", sub: "" }
        ];

        let textIndex = 0;
        const mainEl = document.getElementById('main-phrase');
        const subEl = document.getElementById('sub-phrase');

        setInterval(() => {
            mainEl.classList.replace('fade-in', 'fade-out');
            subEl.classList.replace('fade-in', 'fade-out');
            setTimeout(() => {
                textIndex = (textIndex + 1) % phrases.length;
                mainEl.innerText = phrases[textIndex].main;
                subEl.innerText = phrases[textIndex].sub;
                mainEl.classList.replace('fade-out', 'fade-in');
                subEl.classList.replace('fade-out', 'fade-in');
            }, 1500);
        }, 6000);

        // --- AUTOPILOT LOGIC ---
        const CONFIG = {
            minInternal: 0.11, 
            boostMinInternal: 4.0, 
            boostMaxInternal: 4.8,
            cycleMin: 24000, 
            cycleMax: 25000, 
            boostDurMin: 14000, 
            boostDurMax: 15000
        };

        let isAutopilot = true;
        let speed = CONFIG.minInternal;
        let targetSpeed = CONFIG.minInternal;
        let nextActionTime = Date.now() + 24000; 
        let isBoosting = false;

        // UI Refs
        const slider = document.getElementById('speed-slider');
        const fill = document.getElementById('throttle-fill');
        const display = document.getElementById('velocity-display');
        const btn = document.getElementById('autopilot-btn');
        const btnStatus = document.getElementById('btn-status');

        slider.addEventListener('mousedown', () => toggleAutopilot(false));
        slider.addEventListener('input', (e) => {
            if(isAutopilot) toggleAutopilot(false);
            const pct = e.target.value / 100;
            targetSpeed = pct * 5.0; 
        });

        window.toggleAutopilot = function(state) {
            if (state !== undefined) isAutopilot = state;
            else isAutopilot = !isAutopilot;

            if (isAutopilot) {
                btn.classList.replace('btn-manual', 'btn-auto');
                btnStatus.innerText = "ENGAGED";
                btnStatus.classList.add('animate-pulse');
                targetSpeed = isBoosting ? targetSpeed : CONFIG.minInternal;
            } else {
                btn.classList.replace('btn-auto', 'btn-manual');
                btnStatus.innerText = "MANUAL";
                btnStatus.classList.remove('animate-pulse');
            }
        };

        function updateAutopilotLogic() {
            if (!isAutopilot) return;
            const now = Date.now();
            if (isBoosting) {
                if (now >= nextActionTime) {
                    isBoosting = false;
                    targetSpeed = CONFIG.minInternal;
                    nextActionTime = now + CONFIG.cycleMin + Math.random() * (CONFIG.cycleMax - CONFIG.cycleMin);
                }
            } else {
                if (now >= nextActionTime) {
                    isBoosting = true;
                    targetSpeed = CONFIG.boostMinInternal + Math.random() * (CONFIG.boostMaxInternal - CONFIG.boostMinInternal);
                    nextActionTime = now + CONFIG.boostDurMin + Math.random() * (CONFIG.boostDurMax - CONFIG.boostDurMin);
                }
            }
            slider.value = (speed / 5.0) * 100; 
        }

        // --- 3D SCENE ---
        let scene, camera, renderer, composer, starSystem, debrisSystem;
        let mouse = new THREE.Vector2();
        let bloomPass, rgbPass, afterimagePass;

        const PALETTE = [0x00ffff, 0xff00ff, 0x8a2be2, 0x00bfff, 0xffd700, 0xffffff];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002); 

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 0;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dl = new THREE.DirectionalLight(0xffffff, 2);
            dl.position.set(0, 10, 10);
            scene.add(dl);
            const pl = new THREE.PointLight(0x0088ff, 2, 800);
            pl.position.set(0,0,-200);
            scene.add(pl);

            createObjects();
            setupPost();

            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
        }

        function createObjects() {
            // STARS
            const geo = new THREE.BufferGeometry();
            const pos = [], col = [];
            const c = new THREE.Color();
            for(let i=0; i<6000; i++) {
                pos.push(
                    Math.cos(Math.random()*6.28)*(10+Math.random()*200),
                    Math.sin(Math.random()*6.28)*(10+Math.random()*200),
                    (Math.random()-0.5)*4000
                );
                c.setHex(PALETTE[Math.floor(Math.random()*PALETTE.length)]);
                col.push(c.r, c.g, c.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(col,3));
            starSystem = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.7, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
            }));
            scene.add(starSystem);

            // DEBRIS
            debrisSystem = [];
            const geoms = [
                new THREE.IcosahedronGeometry(1,0),
                new THREE.BoxGeometry(1,1,1),
                new THREE.TorusGeometry(0.8,0.2,8,16),
                new THREE.ConeGeometry(0.6,1.5,8),
                new THREE.OctahedronGeometry(1,0)
            ];
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x111111, roughness: 0.3, metalness: 0.9, wireframe: true,
                emissiveIntensity: 0.9
            });

            for(let i=0; i<90; i++) {
                const g = geoms[Math.floor(Math.random()*geoms.length)];
                const m = baseMat.clone();
                m.emissive.setHex(PALETTE[Math.floor(Math.random()*PALETTE.length)]);
                const mesh = new THREE.Mesh(g, m);
                resetDebris(mesh, true);
                mesh.userData = { rot: {x:Math.random()*0.05, y:Math.random()*0.05, z:Math.random()*0.05} };
                scene.add(mesh);
                debrisSystem.push(mesh);
            }
        }

        function resetDebris(mesh, init) {
            mesh.position.z = init ? (Math.random()*2000 - 1000) : -1000;
            const r = 15 + Math.random()*50;
            const a = Math.random()*6.28;
            mesh.position.x = Math.cos(a)*r;
            mesh.position.y = Math.sin(a)*r;
            const s = 0.5 + Math.random()*3;
            mesh.scale.set(s,s,s);
            mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
        }

        function setupPost() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            
            // Bloom
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.6; bloomPass.radius = 0.6;
            composer.addPass(bloomPass);

            // Afterimage (Smear)
            afterimagePass = new AfterimagePass();
            afterimagePass.uniforms['damp'].value = 0.8; // Base inertia
            composer.addPass(afterimagePass);

            // RGB Shift
            rgbPass = new ShaderPass(RGBShiftShader);
            rgbPass.uniforms['amount'].value = 0.001;
            composer.addPass(rgbPass);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateAutopilotLogic();

            // HEAVY INERTIA (Slower acc/dec)
            // Changed from 0.02 to 0.005 for massive weight feel
            speed += (targetSpeed - speed) * 0.003;

            // UI
            const visualC = (speed * 0.5).toFixed(2);
            display.innerText = visualC;
            if(speed > 3.0) {
                display.classList.add('text-red-500');
                display.classList.remove('text-cyan-300');
            } else {
                display.classList.remove('text-red-500');
                display.classList.add('text-cyan-300');
            }
            fill.style.height = (speed / 0.05) + '%'; 

            // Motion
            const spd = speed * 2;
            const pos = starSystem.geometry.attributes.position.array;
            for(let i=2; i<pos.length; i+=3) {
                pos[i] += spd;
                if(pos[i] > 200) pos[i] = -1800;
            }
            starSystem.geometry.attributes.position.needsUpdate = true;
            starSystem.rotation.z += 0.0001 * speed;

            debrisSystem.forEach(m => {
                m.position.z += spd * 1.5;
                m.rotation.x += m.userData.rot.x;
                m.rotation.y += m.userData.rot.y;
                m.rotation.z += m.userData.rot.z;
                if(m.position.z > 100) resetDebris(m);
            });

            camera.position.x += ((mouse.x * 8) - camera.position.x) * 0.03;
            camera.position.y += ((mouse.y * 8) - camera.position.y) * 0.03;
            camera.rotation.z = -mouse.x * 0.1;

            // DYNAMIC FX
            camera.fov = 70 + (speed * 3);
            camera.updateProjectionMatrix();
            
            // RGB Shift increases with speed
            rgbPass.uniforms['amount'].value = 0.0005 + (speed * 0.002);
            
            // Smear (Damp) increases with speed
            // Low speed = 0.7 (clearer), High speed = 0.96 (super blurry trails)
            const smearFactor = 0.7 + (Math.min(speed, 5.0) / 5.0) * 0.26;
            afterimagePass.uniforms['damp'].value = smearFactor;

            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
